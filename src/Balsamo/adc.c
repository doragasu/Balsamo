/*************************************************************************//**
 * \file adc.c
 * \brief Manages the internal 12 bit ADC. It configures the ADC for the 16
 * bit fractional mode and 16 samples per interrupt. Sampling frequency is
 * set to 7200 Hz (1600 * 6), generated by TIMER3. Only pin AN3 is sampled.
 *
 * \author Jesus Alonso Fernandez (doragasu)
 * \warning The module is not generalized for more than two frames.
 * \note When ADRC is active, tconf = 21 us (47 ksps)
 * \license GPL-3.0+ <http://www.gnu.org/licenses/gpl.html>
 *****************************************************************************/
/* This file is part of BALSAMO source package.
 *
 * BALSAMO is free software: you can redistribute
 * it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation, either
 * version 3 of the License, or (at your option) any later version.
 *
 * Some open source application is distributed in the hope that it will
 * be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with BALSAMO.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "common.h"
#include <p30f6014.h>
#include "adc.h"
#include "system.h"

/// Buffer for captured data. Length is the number of samples per frame by the
/// number of frames plus the number of delays used by the FSK demodulator
/// \warning It must be located in X-data memory for the demodulator to work.
fractional _XDATA(2) data[NF * NS + ND];

/// Sample index for the buffer
int dataPos;
/// Index pointing to the input samples of a COMPLETE buffer, starting from
/// the positions of the delays
int framePos;

/************************************************************************//**
 * \brief Initialises ADC module, including TIMER3.
 ****************************************************************************/
void AdcInit(void)
{
	int i;

	/// Initialise input buffer
	for (i = 0; i < (NF*NS + ND); i++)
	{
		data[i] = 0;
	}
	// Configure analog pins, voltage reference and digital I/O
	// Select ADC input channels
	// Select ADC conversion clock
	// Select ADC conversion trigger

	/// Configure ADCON1 register.
	/// \note ADSIDL defaults to 0 (and needs no change).
//	ADCON1bits.FORM = 3;	// Fractional mode
//	ADCON1bits.SSRC = 2;	// TIMER3 starts conversion
//	ADCON1bits.ASAM = 1;	// Sampling starts before the last conversion
	ADCON1 = (3<<8) | (2<<5) | (1<<2);

	/// Configure ADCON2 register
	ADCON2bits.SMPI = 15;	// 16 samples per interrupt

	/// Configure ADCON3 register
	// For Fs=7200Hz, Tconv=138,889us. Thus Tad(max)=9.921us
	// With ADCS=63 and Fcy=22.1184/4 MHz, Tad=5.79us
	// \todo SAMC?
	ADCON3bits.ADCS = 63;

	/// Configure TIMER3 for FS
	T3CONbits.TCKPS = 3;		// Prescaler 1:256
	PR3 = (FCY/256)/FS - 1;		// Count: 3 cycles; PR3 <-- 2
	IEC0bits.T3IE = 0;

	/// Select AN3 in ADCHS
	ADCHS = 0x0003;

	/// Disable Channel Scanning
	ADCSSL = 0x0000;


	/// Configure ADPCFG register
	ADPCFG = ~0x0008;		// All pins are digital inputs, exceptin AN3,
							// configured as analog input.

	/// Enable ADC interrupt
	IEC0bits.ADIE = 1;
}

/************************************************************************//**
 * \brief Starts ADC (and indirectly, also TIMER3)
 ****************************************************************************/
void AdcStart(void)
{
	/// Set buffer pointers
	dataPos = ND;	// Skip delay positions
	framePos = 0;

	/// Restart TIMER3
	TMR3 = 0x0000;
	IFS0bits.T3IF = 0;

	/// Clear ADC interrupt
	IFS0bits.ADIF = 0;

	/// Enable ADC
	ADCON1bits.ADON = 1;

	/// Enable TIMER3
	T3CONbits.TON = 1;
}

/************************************************************************//**
 * \brief Stops ADC (and indirectly also TIMER3).
 ****************************************************************************/
void AdcStop(void)
{
	/// Just disable ADC and TIMER3
	T3CONbits.TON = 0;
	ADCON1bits.ADON = 0;
}

/************************************************************************//**
 * \brief ADC interrupt routine
 ****************************************************************************/
void __attribute__((__interrupt__)) _ADCInterrupt(void)
{
	int i;
	volatile fractional* adc = (volatile fractional*)&ADCBUF0;

	/// Clear TIMER3 interrupt flag
	IFS0bits.T3IF = 0;

	/// Clear ADC interrupt flag
	IFS0bits.ADIF = 0;

	/// Copy sampled dada.
	for (i = 0; i < 16; i++, dataPos++)
	{
		data[dataPos] = adc[i];
	}
	/// Generate processing event if buffer complete.
	//  Remember NS is multiple of 16
	if (dataPos == (ND + NS))
	{
		// A buffer for frame 1 is completed
		// Raise processing event
		framePos = 0;
		SysIQueuePut(SYS_DATA);
	}
	else if (dataPos == (ND + 2*NS))
	{
		// Completed a buffer for frame 2
		// Restart pointer and copy the last 3 values to the beginning of frame
		for (dataPos = 0; dataPos < ND; dataPos++)
		{
			data[dataPos] = data[NF*NS + dataPos];
		}
		// Raise processing event
		framePos = NS;
		SysIQueuePut(SYS_DATA);
	}
}

/************************************************************************//**
 * \brief Gets the pointer to the last received pointer
 ****************************************************************************/
fractional* AdcGetBuf(void)
{
	return &data[framePos];
}

